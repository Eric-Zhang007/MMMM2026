你是资深机器学习工程师。请从零实现一个可运行的 Python 项目，用于从 DWTS_Long_Format_Data.csv 中反推出每季每周的粉丝投票百分比，并用 MAP 形式拟合真实淘汰结果。项目必须支持第 1 到 34 季的两种赛制百分比合成与名次合成，并对第 28 季及之后的“评委在倒数两对中二选一淘汰”提供可选的附加损失项。代码必须可运行，结构统一，变量命名一致，支持 XPU/GPU，支持多线程数据处理，支持超参数搜索。

一，输入数据与基本定义
输入文件为 CSV，列名固定如下。每行代表某季的一位 celebrity 与其 ballroom_partner 组成的组合。
关键列
celebrity_name
ballroom_partner
celebrity_industry
celebrity_homestate
celebrity_homecountry/region
celebrity_age_during_season
season
results
placement
week1_judge1_score 到 week11_judge4_score 共 44 列，某些季不存在的周为 NaN，淘汰后后续周记为 0

请把每对组合视为一个 team，team_id 用字符串 f"{celebrity_name}__{ballroom_partner}"，同时构造 celebrity_id 与 dancer_id 的索引映射。

二，按季按周生成长表面板
把宽表转换成长表 records(s, t, team_id)。对每个 season s，自动识别本季存在的最大周数 T_s。判定方式为，在该 season 内某个 weekt_judge*_score 至少存在一个非 NaN，则认为 week t 存在。
对每个 (s,t,team) 计算
J_total[s,t,i] = sum_j weekt_judgej_score，忽略 NaN
active[s,t,i] = 1 当且仅当 J_total > 0
若本季该周所有 team 均 active=0 或该周不存在，则跳过

对每个 (s,t) 的 active 集合 A_{s,t} 计算
J_pct[s,t,i] = J_total[s,t,i] / sum_{k in A} J_total[s,t,k]
zJ[s,t,i] = (J_total[s,t,i] - mean_{k in A} J_total[s,t,k]) / (std_{k in A} J_total[s,t,k] + eps)
dzJ[s,t,i] = zJ[s,t,i] - zJ[s,t-1,i]，若 t=1 或上周不 active 则取 0
judge_rank rJ[s,t,i]，按 J_total 降序排名，最好为 1，最差为 |A|

淘汰标签来自 active 的变化
对每个周 t 且 t < T_s，定义
Losers L_{s,t} = { i in A_{s,t} 且 active[s,t+1,i] = 0 }
Winners W_{s,t} = A_{s,t} \ L_{s,t}
若 |L_{s,t}|=0 则该周不产生 base loss

Withdraw 处理
若 results 为 Withdrew，可用 active 变化自动捕捉离开周。无需依赖 results 文本。

三，模型参数与特征 x_i
用 PyTorch 实现参数
theta[celebrity_id] 为标量 embedding
u[dancer_id] 为标量 embedding
phi 为特征权重向量

特征向量 x_i 的构造要求
age 连续值，做标准化
industry 类别 one hot
homecountry/region 类别 one hot
homestate 可选，建议做大类 one hot 或直接 one hot，默认开启 one hot 并允许在 config 关闭
最终 x_i 为固定张量，shape 为 [num_teams, K]

四，核心公式必须严格实现

身份分与表现分
IdentityScore_i = theta[celebrity(i)] + u[dancer(i)] + dot(phi, x_i)

PerformanceScore_{i,t} = beta1 * zJ_{i,t} + beta2 * dzJ_{i,t}
beta 为长度 2 的可学习参数，beta1 对 zJ，beta2 对 dzJ

动态权重 alpha_t 采用方差比，必须可微
对每个 (s,t) 的 active 集合 A 计算
sigma_fan2[s,t] = Var_{i in A}(IdentityScore_i)
sigma_judge2[s,t] = Var_{i in A}(PerformanceScore_{i,t})
alpha[s,t] = sigma_judge2[s,t] / (sigma_judge2[s,t] + k * sigma_fan2[s,t] + eps)

k 为超参数，可学习或固定。默认固定，加入调参空间。

潜能分 eta 与粉丝投票百分比
eta_{i,t} = (1 - alpha[s,t]) * IdentityScore_i + alpha[s,t] * lambda_perf * PerformanceScore_{i,t}

粉丝投票百分比
P_fan_{i,t} = softmax_{i in A}(eta_{i,t})

赛制区间与当周综合分 S_total
赛制标签 rule_type 仅由 season 决定
season 1-2 用 rank
season 3-27 用 pct
season 28-34 用 rank

pct 赛制
S_total_{i,t} = J_pct_{i,t} + C * P_fan_{i,t}

rank 赛制
需要可导的粉丝软名次 soft_rank_fan
soft_rank_fan_{i,t} = 1 + sum_{k in A, k != i} sigmoid( (eta_{k,t} - eta_{i,t}) / tau_rank )
总名次
TotalRank_{i,t} = rJ_{i,t} + soft_rank_fan_{i,t}
为统一 hinge 的方向，定义
S_total_{i,t} = -TotalRank_{i,t}
这样 S_total 越大代表越安全

注意
J_pct 与 P_fan 在 [0,1] 同尺度，C 默认 1.0
rank 赛制下用 eta 做 soft_rank，可保持端到端可导

五，损失函数与先验正则，统一到 1-34 季
总损失
L = sum_{s,t} L_base[s,t] + sum_{s,t} I_twist[s,t] * (lambdaA * L_A[s,t] + lambdaB * L_B[s,t]) + L_prior

Base loss 为 pairwise hinge，必须按周归一化
对每个 (s,t) 且 |L_{s,t}|>0
L_base[s,t] = mean_{i in W_{s,t}, j in L_{s,t}} relu( xi_margin - (S_total_{i,t} - S_total_{j,t}) )

Twist 仅对 season >= 28 的特定周启用
I_twist[s,t] 的默认规则
season >= 28 且 |L_{s,t}| == 1 且 |A_{s,t}| > 2 且 t < T_s
允许在 config 覆盖

Twist 的观测限制
数据没有显式 bottom2 信息，所以用一个可复现实用近似
令 e 为唯一淘汰者
令 s_proxy 为当周幸存者中 S_total 最小者，即 s_proxy = argmin_{i in W} S_total_{i,t}

L_A 目标为让 e 与 s_proxy 成为最危险的两位
定义 risk_{i,t} = -S_total_{i,t}
用 hinge 强制除 {e, s_proxy} 外的任何人都更安全
L_A = mean_{k in A, k not in {e,s_proxy}} [ relu( xi_twist - (S_total_{k,t} - S_total_{e,t}) ) + relu( xi_twist - (S_total_{k,t} - S_total_{s_proxy,t}) ) ]
可以在实现里对 k 做子采样加速，默认全量向量化

L_B 目标为模拟评委二选一倾向淘汰评委更差者
用评委总分或评委百分比比较即可
L_B = relu( xi_tb - (J_total[s,t,s_proxy] - J_total[s,t,e]) )
也允许用 logistic 版本，默认 hinge，保持风格一致

先验正则
theta 与 u 采用 L2
L_theta = lambda_theta * mean(theta^2)
L_u = lambda_u * mean(u^2)

phi 采用 L1 或 elastic net，默认 L1
L_phi = lambda_phi * ||phi||_1
可选加 L2
L_phi2 = lambda_phi2 * ||phi||_2^2

beta 采用以 1 为中心的 L2，保证评委项不退化
L_beta = lambda_beta * sum_{k in {1,2}} (beta_k - 1)^2
如果你希望更弱的先验，允许中心改为 0，通过 config 控制

L_prior = L_theta + L_u + L_phi + L_phi2 + L_beta

六，训练流程要求
使用 AdamW
支持 GPU
梯度裁剪 clip_grad_norm
随机种子固定
按 season 切分训练与验证，默认训练 1-30，验证 31-34，可在 config 调整
早停 based on 验证集指标

指标至少输出
ElimTop1Acc，真实淘汰者在当周 risk 排名为 1 的比例
ElimInBottom2Acc，真实淘汰者在当周 risk 排名后两位的比例
MeanMargin，平均 S_total(winner) - S_total(loser)
以及 loss 各分量的均值

每次训练保存
outputs/run_name/config_resolved.yaml
outputs/run_name/formulas.txt
outputs/run_name/metrics.json
outputs/run_name/model.pt
outputs/run_name/pred_fan_shares.csv，包含 season, week, team_id, P_fan, S_total, alpha

formulas.txt 必须逐行打印并写入
eta 公式
alpha 公式
pct 赛制 S_total 公式
rank 赛制 soft_rank 公式
base hinge 公式
twist L_A 与 L_B 公式
正则项公式

七，超参数搜索
使用 Optuna 实现贝叶斯优化，默认 TPE
搜索空间建议
k in [0.1, 10] log-uniform
lambda_perf in [0.5, 5] log-uniform
C in [0.5, 5] log-uniform
xi_margin in [0.0, 1.0] uniform
tau_rank in [0.1, 2.0] log-uniform
lambda_theta, lambda_u in [1e-4, 1e-1] log-uniform
lambda_phi in [1e-4, 1e-1] log-uniform
lambda_beta in [1e-4, 1e-1] log-uniform
lambdaA, lambdaB in [0.0, 2.0] uniform
xi_twist, xi_tb in [0.0, 1.0] uniform

objective 为验证集上 ElimInBottom2Acc 最大化，若并列则 MeanMargin 最大化，或用加权综合分
Optuna n_jobs 支持多线程并行 trial
每个 trial 训练 epoch 数可减小，并启用早停

八，项目目录结构与代码风格必须一致
生成如下目录结构
project_root/
README.md
requirements.txt
configs/
default.yaml
tune.yaml
src/
init.py
data.py
features.py
model.py
losses.py
train.py
evaluate.py
tune.py
utils.py
outputs/
scripts/
run_train.sh
run_tune.sh

代码风格要求
Python 3.10+
类型标注
f-string
日志用 logging
函数命名 snake_case
类命名 CamelCase
同一概念变量名固定
season 用 s
week 用 t
team 用 i
active 集合用 A
winners 用 W
losers 用 L
所有超参数从 config 读取，不允许散落 magic number

九，健壮性要求
对 NaN 与 0 分严格区分
std 过小加 eps
某周 active 人数小于 3 时跳过 twist
某周没有淘汰时 base loss 为 0
多淘汰周必须支持
支持 CPU 下运行，速度可接受
数据加载与特征编码可多进程加速

十，自检要求
在 evaluate.py 中提供一个 sanity_check 模式
随机抽取一个 season-week，打印
active 数量
W 和 L 的 team_id 列表
计算得到的 J_pct，rJ，alpha，P_fan，S_total 的前 5 与后 5
确认符号方向一致
winner 的平均 S_total 大于 loser 的平均 S_total

请严格按上述要求生成完整代码，可直接运行。输出必须包含 formulas.txt 作为公式自检。